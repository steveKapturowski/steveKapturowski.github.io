<head>
<meta charset="utf-8">
<style>
.hide {
  display: none;
}
.rect {
  fill: none;
  stroke: hsl(0, 0%, 70%);
}
.vrange {
  margin-top: 0px;
  transform: rotate(90deg);
  -moz-transform: rotate(90deg);
}
</style>
</head>
<center>
  <p>
    <input id="temperature" type="range" value="2.5" min="0.0" max="5.0" step="0.01" list="tickmarks">
<!--     <datalist id="tickmarks">
      <option>0</option>
      <option>1</option>
      <option>2</option>
      <option>3</option>
      <option>4</option>
      <option>5</option>
    </datalist> -->
    <label> Temperature [kT/J]</label>
  </p>
  <p>
    <foo></foo>
    <!-- <input id="speed" type="range" value="2.5" min="0.0" max="5.0" step="0.01"><label>Speed</label> -->
  </p>
  <p>
<!--     <select id="model">
      <option value="ising">Ising</option>
      <option value="xy">XY</option>
    </select> -->
    <select id="algorithm">
      <option value="wolff">Wolff</option>
      <option value="metropolis">Metropolis</option>
    </select>
  </p>
</center>


<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
(function() {
  "use strict";

  var
    margin = {top: 40, right: 100, bottom: 40, left: 150},
    W = 300,
    H = 300,
    w = W - margin.left - margin.right,
    h = H - margin.top - margin.bottom,

    xmax   = 1.5,
    rate   = 1 / 10000,
    T = 2.5,
    N = 48,
    dim = W/N,

    rectangles,
    lattice,
    timer;


  var svg = d3.select("foo")
    .append("svg")
      .attr("width", W)
      .attr("height", H)

  function initLattice(n) {
    var 
      newN = n,
      newDim = W/n,
      newLattice = new Array(Math.pow(newN, 2));

    for (var i=0; i < Math.pow(newN, 2); i++) {
      var x = i % newN;
      var y = Math.floor(i / newN);
      var spin;

      if ( lattice == null ) {
        spin = (Math.random() < .5) ? 1 : -1;
      } else {
        var oldX = Math.floor((x + .5) * N/newN);
        var oldY = Math.floor((y + .5) * N/newN);
        var index = oldX + oldY * N;

        var sites = getNeighbors(index);
        sites.push(index);

        var sum = sites.map(function(j) {
          return lattice[j]["spin"];
        }).reduce(function(a, b) {
          return a + b;
        }, 0);

        spin = (Math.random() > (sum+5)/10) ? -1 : 1;
      }
        
      newLattice[i] = {
        "x": x*newDim,
        "y": y*newDim,
        "height": newDim,
        "width": newDim,
        "spin": spin,
      };
    }

    d3.select("svg").selectAll("rect").remove();
    rectangles = svg.selectAll("rect")
      .data(newLattice)
      .enter()
      .append("rect");

    rectangles
      .attr("x", function (e) { return e.x; })
      .attr("y", function (e) { return e.y; })
      .attr("height", function (e) { return e.height; })
      .attr("width", function (e) { return e.width; })
      .style("fill", function(e) { return (e.spin == 1) ? "black" : "white"; });
    
    N = newN;
    dim = newDim;
    lattice = newLattice;
  }
  initLattice(N);


  function Ising () {}
  Ising.prototype.nearestNeighborInteraction = function(s1, s2) {};
  Ising.prototype.flipSpin = function() {};
  Ising.prototype.render = function() {};

  var models = {
    ising: function(lattice) {
      
    },
    xy: function(lattice) {
      
    },
  };

  function getNeighbors(index) {
    var 
      numSites = Math.pow(N, 2),
      left = index - 1,
      right = left + 2;

    if (index % N == 0) {
      left += N;
    } else if (right % N == 0) {
      right -= N;
    }

    return [
      (index + N + numSites) % numSites, //javascript's mod operation makes mathematicians cry
      (index - N + numSites) % numSites,
      left,
      right,
    ]
  }

  function growChain() {
    var
      chain = {},
      newSites = {},
      addedSites = {},
      index = Math.floor(Math.random()*Math.pow(N, 2));

    chain[index] = true;
    addedSites[index] = true;

    while ( Object.keys(addedSites).length > 0 ) {
      newSites = {};
      Object.keys(addedSites).forEach(function (key) { 
        index = parseInt(key);

        getNeighbors(index).forEach(function (neighbor) { 
          if ( 
            !(neighbor in chain) 
            && ( Math.random() < (1 - Math.exp(-2*lattice[index]["spin"]*lattice[neighbor]["spin"]/T)) )
          ) { 
            chain[neighbor] = true;
            newSites[neighbor] = true;
          }
        });
      });
      addedSites = newSites;
    }
    return Object.keys(chain);
  }

  function flipChain(indices) {
    indices.forEach(function (index) { 
      lattice[index]["spin"] *= -1;
    });
    return indices
  }

  var algorithms = {
    metropolis: function() {
      var 
        index = Math.floor(Math.random()*Math.pow(N, 2)),
        Edelta = 0;

      getNeighbors(index).forEach(function (neighbor) { 
        Edelta -= 2 * lattice[index]["spin"] * lattice[neighbor]["spin"];
      });
      if (Math.random() < Math.exp(Edelta/T)) {
        lattice[index]["spin"] *= -1;
      }
      return [index];
    },
    wolff: function() {
      return flipChain(growChain()); // return modified indices
    },
  };

  var 
    algorithm = algorithms.wolff,
    model = models.ising;

  function drawGraph() {
    var indices = algorithm();

    // rectangles = svg.selectAll("rect")
    //   .data(indices.map(function(index) {
    //     return lattice[index];
    //   })); // get rectangles whose spins have been modified
    
    rectangles
      .attr("x", function (d) { return d.x; })
      .attr("y", function (d) { return d.y; })
      .attr("height", function (d) { return d.height; })
      .attr("width", function (d) { return d.width; })
      .style("fill", function(d) { return (d.spin == -1) ? "black" : "white"; });

  }

  function play() {
    if (timer) return;
    (function loop() {
      drawGraph();
      timer = setTimeout(loop, rate * 1000);
    })();
  }

  function togglePause() {
    if (!timer) {

    } else {
      clearTimeout(timer);
      timer = null;
    }
  }

  d3.select("#temperature").on("change", function() { T = this.value; });
  d3.select("#model").on("change", function() { model = models[this.value]; });
  d3.select("#algorithm").on("change", function() { algorithm = algorithms[this.value]; });

  var zoomFactor = 64;
  var zoom = d3.behavior.zoom().scaleExtent([1/16, 1]).on("zoom", function() {initLattice(2*Math.floor(zoomFactor*zoom.scale()/2)); });
  zoom.scale(N/zoomFactor);
  svg.call(zoom);

  play();

})();
</script>